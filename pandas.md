Основные функции Pandas
=======================

```python
import pandas as pd
```

Базовые типы
------------

### `Series`

Это одномерный ассоциативный массив, который может
хранить элементы любого типа (но у всех элементов
тип одинаковый). Множество меток массива называется
**индексом**. В тех случаях, когда индекс не задан
явно, элементы массива нумеруются последовательными
целыми числами, начиная с 0.

`Series` похож на одномерный массив `ndarry` из [NumPy](numpy.md);
большинство функций NumPy будут работать и с объектами `Series`.

### `DataFrame`

Это двумерная таблица, логически состоящая из нескольких
столбцов типа `Series` с одинаковым индексом. Типы данных в
разных столбцах могут быть различными. Сами столбцы также
снабжены метками.


Создание
--------

`Series` может быть создан на основе кортежа, списка или одномерного
`ndarray`. В этом случае индекс может быть задан отдельным кортежем,
списком и т.п.; если индекс не задан явно, элементы будут перенумерованы.

`Series` может быть создан из ассоциативного массива, ключи которого
станут индексом.

`Series` может быть создан из скалярного значения; в таком случае
индекс должен быть задан явно. Все элементы созданного `Series` будут
иметь одно и то же значение.

`DataFrame` может быть создан из ассоциативного массива, содержащего
одномерные структуры: кортежи, списки, одномерный `ndarray` или `Series`.
Индексы всех `Series` объединяются в один.

`DataFrame` может быть создан из двумерного `ndarray`. В этом случае
индекс и метки столбцов могут быть заданы отдельно. Если они не заданы,
в качестве меток/индекса будут использоваться последовательные целые числа.

`DataFrame` может быть создан из списка ассоциативных массивов. Каждый
элемент списка будет соответствовать одной строке, ключи массива --- метки
столбцов.

Загрузка данных
---------------

`read_csv(filename)` загружает `DataFrame` из файла `CSV`.
По умолчанию имена столбцов берутся из первой строки файла,
а индекс --- номера строк. С помощью аргумента `index_col` можно
указать столбец, содержащий индекс. С помощью аргумента `names`
можно задать имена столбцов в явном виде, а если указать `header=None`,
то столбцы будут последовательно пронумерованы.

Аналогичные функции существуют для чтения:
- JSON: `read_json()`
- таблиц HTML: `read_html()`
- файлов MS Excel и OpenOffice Calc: `read_excel()`
- импорта данных из SQL:
  - `read_sql_table()` превращает таблицу SQL в `DataFrame`
  - `read_sql_query()` превращает результат SQL `SELECT` в `DataFrame`

Доступ к данным и фильтрация
----------------------------

Если `x` --- `Series`, то `x[a]` возвращает элемент с индексом `a`.
Если `i` --- целое число, то `x[i]` возвращает `i`-ый элемент,
начиная с нуля. `x[i:j]` возвращает под-`Series` c элементами с номерами с `i`
по `j-1`, а `x[a:b]` (где `a` и `b` имеют тип индекса `x`) возвращают
элементы, начиная с индекса `a` по индекс `b` **включительно**.
Если `"attr"` имеет синтакис правильного идентификатора Python, то вместо `x["attr"]`
можно писать просто `x.attr`.

Если `df` --- DataFrame, то `df[a]` возвращает столбец (как `Series`)
с меткой `a`. `df[i:j]` возвращает `DataFrame` со строками c `i` по `j-1`.

Если `bv` --- булевский вектор (список, одномерный `ndarray` или `Series`,
то `x[bv]` возвращает под-`Series`, который включает только элементы,
в позиции которых в `bv` стоит `True`.
Аналогично `df[bv]` возвращает `DataFrame` со строками, в позиции которых в `bv`
стоит `True`.

Слияние и соединение
--------------------

`pd.concat([df1, df2, ...])` соединяет `DataFrame` вдоль вертикальной оси, т.е.
результирующий `DataFrame` будет содержать сначала все строки из `df1`, потом из `df2` и т.д.

`pd.concat([df1, df2, ...])` соединяет `DataFrame` вдоль вертикальной оси, т.е.
результирующий `DataFrame` будет содержать сначала все столбйы из `df1`, потом из `df2` и т.д.

Метки строк (в первом случае) и столбцов (во втором) не изменяются, т.е. если в `df1` строки
нумеровались от `0` до `N`, а в `df2` --- от `0` до `M`, то в результирующем `DataFrame`
будут **две** cтроки с номером `0`. Чтобы автоматически перенумеровать строки (столбцы)
последовательными числами, следует использовать аргумент `ignore_index=True`.

Метки могут быть изменены:
- c помощью метода `.reindex(new_indices)` --- при этом изменяется порядок следования
  строк или столбцов. Если каких-либо индексов из `new_indices` в исходном объекте нет,
  соответствующие значения будут неопределенными (`NaN`);
- с помощью метода `.rename(f)`, который переименовывает существующие индексы, например,
  `df.rename(lambda i: i + 1)` увеличивает метки-номера строк на 1, а
  `df.rename({'a': 'x', 'b': 'y'}, axis=1)` заменит имя столбца `а` на `x`,
  а `b` --- на `у`.

Соединение (в смысле реляционной алгебры) выполняется с помощью функции
`pd.merge(df1, df2, how=MODE, on=COLUMN)`: при этом конструируется `DataFrame`
который будет содержать все столбцы из `df1` и `df2`, а строки будут подмножеством
картезианского произведения `df1` и `df2`, такого что столбец `COLUMN` в обоих
таблицах имеет одинаковое значение:

| index | key | A  | B  |
|-------|-----|----|----|
| 0     | K0  | A0 | B0 |
| 1     | K1  | A1 | B1 |
| 2     | K0  | A2 | B2 |
| 3     | K1  | A3 | B3 |

| index | key | C  | D  |
|-------|-----|----|----|
| 1     | K0  | C0 | D0 |
| 2     | K0  | C1 | D1 |
| 3     | K1  | C2 | D2 |
| 4     | K1  | C3 | D3 |

`pd.merge(df1, df2, on='key')` ⇒

| index | key | A  | B  | C  | D  |
|-------|-----|----|----|----|----|
| 0     | K0  | A0 | B0 | C0 | D0 |
| 1     | K0  | A0 | B0 | C1 | D1 |
| 2     | K0  | A2 | B2 | C0 | D0 |
| 3     | K0  | A2 | B2 | C1 | D1 |
| 4     | K1  | A1 | B1 | C2 | D2 |
| 5     | K1  | A1 | B1 | C3 | D3 |
| 6     | K1  | A3 | B3 | C2 | D2 |
| 7     | K1  | A3 | B3 | C3 | D3 |

Режим `how` определяет вид соединения:
- `inner` (по умолчанию): в результат попадают только строки с общим ключом;
- `left`: в добавление к `inner` в результат попадают все строки из `df1`, для которых
  в `df2` нет соответствия, столбцы из `df2` заполняются `NaN`;
- `right`: в добавление к `inner` в результат попадают все строки из `df2`, для которых
  в `df1` нет соответствия, столбцы из `df1` заполняются `NaN`;
- `outer`: объединение `left` и `right`.

Операции
--------

Аналогично `ndarray` из `NumPy` арифметические и логические операции применяются 
к `Series` и `DataFrame` поэлементно. Если операнды имеют различные индексы и/или
метки столбцов, то операция применяется только к значениям с общими метками, остальные
элементы будут заполнены `NaN`.

Функции могут быть применены к каждой строке или к каждому столбцу по отдельности,
например, `df.apply(np.mean, axis=1)`.

Функции могут быть применены и к каждому элементу в отдельности: `df.applymap(str.upper)`.

Статистика
----------

Стандартные статистические функции являются методами `Series` и `DataFrame`:

- `.count()`: количество элементов
- `.sum()`: сумма элементов
- `.mean()`: арифметическое среднее
- `.median()`: медиана
- `.min()`: минимум
- `.max()`: максимум
- `.std()`: среднеквадратичное отклонение

Для `Series` результатом будет скалярная величина, для `DataFrame` --- `Series`.
В последнем случае аггрегирование по умолчанию происходит по строкам, т.е. в
результирующей `Series` будет столько же элементов, сколько было **столбцов** в
исходном `DataFrame`. Чтобы получить аггрегирование по столбцам,
надо использовать `axis=1`.

Метод `.corr()` может быть использован для нахождения коэффициента корреляции
- между двумя `Series`: `x.corr(y)`;
- попарно между столбцами `DataFrame`: `df.corr()`.


Группировка
-----------

`df.groupby(COLUMN)` или `df.groupby([COLUMN1, COLUMN2, ...)` используются
для того, чтобы разбить таблицу `df` на группы с равным значением столбца `COLUMN`
(или нескольких столбцов `COLUMN1`, `COLUMN2` ...).

Отдельные подтаблицы могут быть получены:
- итерацией с помощью цикла `for`;
- вызовом метода `.get_group(VALUE)`, который вернет таблицу с группировочным значением `VALUE`

К объекту группировки применимы статистические методы наподобие `.mean()`, которые
возвращают `DataFrame` со строками, соответствующими группам. Значения всех негруппировочных
столбцов будут аггрегированы (например, вычислено их среднее по группе).

Окна
----

Статистические функции могут быть применены не ко всех совокупности строк (столбцов) в 
таблице, а к некоторому их промежутку («окну»):

    `df.rolling(window=10).mean()`

усредняет значения каждый десяти смежных строк в исходной таблице.

Объекты, полученные в результате вызова `.rolling()` также могут итерироваться с помощью
цикла `for`.

Визуализация
------------

```
df.plot()
```

изобразит линейные графики значений всех столбцов `df` по оси y,
а значения индексов -- по оси x.

```
df.plot(x=A, y=B)
```

изобразит зависимость столбца B от A


`.plot(kind=KIND)` может изображать разные типы графиков, в т.ч.:

- `bar`: столбчатые диаграммы
- `hist`: гистограммы
- `scatter`: графики рассеяния
- `pie`: круговые диаграммы

```
import matplotlib.pyplot as plt
plt.show()
```

покажет построенную диаграмму интерактивно.

```
plt.savefig(IMAGE_FILENAME)
```

сохранит диаграмму в одном из поддерживаемых форматов (например, PNG).

Сохранение данных
-----------------

Сохранение таблицы в формат CSV:

```
df.to_csv(FILENAME)
```

Первый столбец в полученном файле будет содержать индекс;
чтобы не включать индекс, следует передать параметр `index=False`.

Аналогично определены методы:
- `.to_json(FILENAME)` --- cохранение в формат JSON;
- `.to_html(FILENAME)` --- сохранение в виде таблицы HTML;
- `.to_excel(FILENAME)` -- сохранение в формат XLS(X) MS Excel;
- `.to_sql(TABLE, CONN)` --- запись в таблицу базы данных `TABLE`.
