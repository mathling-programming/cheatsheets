Краткий справочник по командам Git
==================================


## Getting started

Install Git on Debian (if not yet).

``` shell
apt install git git-doc git-man git-email
```



Create configuration file `.gitconfig` in your home directory:

``` shell
git config --global user.name "John Doe"
git config --global user.email John.Doe@oktetlabs.ru
   
git config --global push.default simple
```

Клонирование репозитория
------------------------

``` shell
git clone https://github.com/mathling-programming/practice2022.git
```

Режим "для чтения"
------------------

Если хотите только исследовать и использовать содержимое репозитория.


### Обновление репозитория


#### `git pull`

1. Загрузка изменений из удаленного репозитория
2. Применение загруженных изменений к текущей ветке


#### `git fetch`

Только загрузка изменений.


### Просмотр списка веток

#### `git branch`

Список локальных веток.


#### `git branch -a`

Список всех известных веток, локальных и удаленных.

#### `git tag -l`

Список всех тегов.

### Просмотр истории и изменений

#### `git log`

Просмотр истории с полными описаниями.

#### `git log --oneline`

Просмотр истории с кратким описаниями (первые строчки commit messages)

#### `git show`

Содержимое головного коммита в текущей ветке.

#### `git show 1e447bcc61e`

Содержимое конкретного коммита по его идентификатору (хэшу).

#### `git diff v19.08-rc3..v19.08-rc4`

Просмотр различий между двумя произвольными ревизиями.


### Переключение на заданную ветку, тег или произвольную ревизию

``` shell
git checkout stable-18.11
git checkout v18.11.2
git checkout 1e447bcc61ec52005c3fac466d9c149be39979d2
```

Порядок разработки
------------------

### Начало работы

Ветки в Git не тратят никаких ресурсов, поэтому разработка должна вестить в отдельных локальных
ветках, которые потом могут быть опубликованы.

Ветка, начинающаяся от текущей ревизии создается командной:


``` shell
git checkout -t -b my_feature_branch
```

Следующая команда позволяет увидеть изменения, которые еще не были закоммичены и
не попали в _индекс_:

``` shell
git diff
```

Команда

``` shell
git add <list-of-files>
```

добавляет указанные файлы в _индекс_, т.е. в список объектов, которые будут
закоммичены в следующий раз.

Изменения, попавшие в индекс, уже не отображаются командой `git diff`.

Однако с помощью команды

``` shell
git diff --staged
```

можно увидеть содержимое индекса.


Наконец, команда
``` shell
git commit
```
создает на основе индекса коммит. При этом будет вызван текстовый редактор,
который позволяет задать описание коммита. Описание состоит из двух частей:
резюме (summary) в первой строчке и детального описания (все остальное).
Детальное описание обязательно отделяется от резюме пустьрой строкой.


Только что созданный коммит может быть изменен c помощью команды:

``` shell
git commit --amend
```

Отметим, что в силу архитектуры Git старый коммит на самом деле не изменяется;
в действительности создается новый коммит, который становится головным в текущей
ветки. Идентификатор старого коммита при этом можно узнать с помощью команды
`git reflog` (см. ниже)

После того, как создано несколько коммитов, их можно изменять и переупорядочивать с помощью
интерактивной команды:


``` shell
git rebase -i
```

Эта команда открывает в текстовом редакторе список коммитов с их краткими описаниями, и
командами, которые к ним можно применить:

- изменение порядка строк меняет порядок коммитов
- удаление строк исключает соответствуюшие коммиты из текущей ветки (скорее всего, делая
  их недоступными)
- `fixup` и `squash` позволяют соединить данный коммит с предыдущим (при этом `fixup`
  оставляет только описание первого коммита, а `squash` создает новое описание, соединяя
  два существующих
- `exec` позволяет запустить произвольную команду в контексте данного коммита
- `reword` позволяет интерактивно изменить описание коммита

Наконец, команда `edit` приводит к тому, что данный коммит временно назначается головным.
В этом состоянии можно изменять и добавлять файлы. Измененные файлы добавляются в индекс
с помощью, как обычно, команды `git add`. Когда все изменения закончены, используйте 

``` shell
git rebase --continue
```

чтобы модифицировать текущий коммит и применить все последующие.

Если в процессе работы `git rebase -i` возникают конфликты, применение коммитов останавливается
(аналогично команде `edit`). После того, как конфликт разрешен, следует сказать `git add` на
соответствующие файлы и `git rebase --continue` (**не следует** в этом случае использовать
`git commit`, это приведет к тому, что текущий (конфликтующий) коммит окажется соединенным с предыдущим).


### Ребейз локальной ветки для синхронизации с исходной веткой

Вернуться на базовую ветку, синхронизировать ее с удаленным репозиторием,
сделать интерактивный ребейз относительного нового состояния базовой ветки:


``` shell
git checkout @{u} # Это сокращение для базовой (апстримной) ветки
git pull
git checkout my_feature_branch
git rebase -i master
```

Если в удаленный репозиторий был сделан force-push:


``` shell
git checkout @{u}
git remote update
git reset @{u}
git checkout my_feature_branch
git rebase -i  # при этом в списке могут оказать "чужие" изменения, их можно просто удалить
```

### Публикация ветки разработки в удаленном репозитории

``` shell
git push origin my_feature_branch:user/$USERNAME/my_feature_branch
```

или

``` shell
git push origin HEAD:user/$USERNAME/my_feature_branch
```

В случае, если локальная ветка была ребейзнута, скорее всего, придется использовать force-push,
потому что текущий коммит не является потомком топового коммита удаленной ветки:


``` shell
git push origin +HEAD:user/$USERNAME/my_feature_branch
```

Когда удаленная ветка больше не нужна, ее можно уничтожить:

``` shell
git push origin :user/$USERNAME/my_feature_branch
```

### Создание pull request PR (в случае GitHub)

В Web-интерфейсе: на странице соотв. репозитория `Pull requests` > `New pull requests` >
`Compare changes`: `main` ↔ `user/$USERNAME/my_feature_branch` > `Create pull request`

### Окончательная интеграция ветки

Внимание: в большинстве случаев окончательная интеграция делается не отдельным разработчиком,
а мейнтейнером репозитория. То, что указано ниже, как правило, применимо к личным репозиториям.

Перед тем, как делать интеграцию, нужно осуществить ребейз как указано выше. Потом:


``` shell
git push origin my_feature_branch:main
```

Делать force-push в ветку main **крайне не рекомендуется**.


## Разные команды

### `git stash`

`git stash` позволяет временно сохранить изменения в рабочем дереве и вернуть его
к состоянию последнего коммита. Сохраненные изменения могут быть восстановлены с
помощью `git stash pop`.

### `git reflog`

`git reflog` позволяет увидеть историю передвижения `HEAD`, т.е. фактически историю
эволюции локальных патчей. Она очень полезна в ситуации, когда необходимо устранить
последствия неудачного `rebase` или force-push.

### `git format-patch`

`git format-patch` позволяет экспортировать патчи в отдельные файлы, которые потом можно
редактировать вручную.
`git am` может быть использована для импорта таких файлов обратно.

